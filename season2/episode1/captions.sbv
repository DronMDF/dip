0:00:00.000,0:00:07.058
мы начинаем новый сезон нашего скринкаста 

0:00:07.058,0:00:10.053
это  первый выпуск в этом году

0:00:10.053,0:00:13.950
и в этом году 
я планирую внести некоторые коррективы

0:00:17.255,0:00:24.422
поработав некоторое мясо скринкастами я понял несколько вещей

0:00:28.168,0:00:32.140
пишу код довольно-таки медленно

0:00:32.140,0:00:34.987
я не вижу в этом проблемы

0:00:34.987,0:00:38.676
но смотреть на это наверное не очень удобно

0:00:38.676,0:00:48.000
из за того что я пишу код медленно 
решение некоторых задач и меня растягиваются

0:00:48.000,0:00:52.866
и выпуски получаются длинными

0:00:52.866,0:01:02.310
поэтому в следующем году я буду меньше писать кода вживую

0:01:06.690,0:01:13.221
буду стремиться к тому чтобы выпуске укладывались 
25 минут

0:01:13.221,0:01:19.092
и посвящать выпуски будут первую очередь тому

0:01:19.092,0:01:28.473
что буду рассматривать в них свои решения

0:01:30.959,0:01:39.875
сам процесс написания кода не так интересен как те решения, которые я стараюсь поменять в этом коде

0:01:39.875,0:01:45.188
и как прежде этот подкаст посвящен моим хобби проектам

0:01:45.188,0:01:49.941
моим экспериментам 
в рамках ООП

0:01:49.941,0:01:55.810
и по-прежнему мы работаем над библиотекой goost

0:01:58.580,0:02:01.773
переходим ближе к теме

0:02:02.686,0:02:07.732
прошлый год 
закончился тем что я набросал какие-то базовые алгоритмы

0:02:07.732,0:02:14.146
этих алгоритмов хватает чтобы 
реализовать некоторые простые приложения

0:02:14.146,0:02:21.660
но я при этом вижу определенные 
проблемы в архитектуре библиотеки

0:02:26.767,0:02:33.843
эти проблемы сказываются в первую 
очередь на скорости

0:02:33.843,0:02:44.036
но боже вас упаси делать какие-то изменения касательно скорости 
без измерений

0:02:44.036,0:02:46.948
никогда так не делайте

0:02:46.948,0:02:54.348
если у вас есть сомнение насчет каких то 
характеристик системы

0:02:54.348,0:02:58.535
сперва стоит измерить

0:02:58.535,0:03:04.601
и понять действительно ли является проблемой

0:03:04.601,0:03:10.615
и как скажутся то изменение, которое вы сделаете

0:03:10.615,0:03:20.608
чтобы понимать как оно скажется вам необходимо иметь какие-то числа с которыми вы можете сравнить

0:03:20.608,0:03:26.895
иногда бывает что значительные 
усилия не приносят какого-либо эффекта

0:03:26.895,0:03:29.517
было как эта история с openbsd'шниками

0:03:29.517,0:03:42.927
которые три дня оптимизировали кусок кода, потом выяснилось что это цикл простя системы

0:03:42.927,0:03:47.917
естественно, что никакого ускорения не возник

0:03:47.917,0:03:56.244
у неплохо было бы сперва задать себе вопрос 
что мы хотим улучшить

0:03:56.244,0:04:01.556
какой параметр системы, важный для пользователя, мы хотим улучшить

0:04:01.556,0:04:06.135
а не просто так оголтело переписывать

0:04:07.268,0:04:17.512
для того, чтобы понять, на что способна эта библиотека в плане скорости 

0:04:17.512,0:04:21.155
я завел отдельный проект

0:04:21.155,0:04:26.506
удобнее сделать это в отдельном проекте

0:04:26.506,0:04:31.681
это приложение которое проводит сравнительный анализ

0:04:37.420,0:04:41.575
здесь пока не так много всего

0:04:47.140,0:04:52.965
и некоторые результаты пока 
что вызывают сомнения

0:04:54.000,0:04:57.606
но как бы то ни было

0:04:58.991,0:05:04.019
мне удалось получить 
некоторые практические результаты

0:05:06.694,0:05:11.389
давайте посмотрим

0:05:11.389,0:05:15.865
в современном openssl 
есть поддержка ГОСТ

0:05:18.351,0:05:25.243
правда там поддерживаются не все алгоритмы а только те, которые востребованы в PKI

0:05:29.523,0:05:32.929
сейчас он немножечко подумает выдаст циферку

0:05:32.929,0:05:36.447
это алгоритм практически 
линейный

0:05:36.447,0:05:40.064
давайте я вам его покажу

0:05:40.914,0:05:46.661
я бы сказал что это совсем не ООП просто си

0:05:46.661,0:05:51.757
за исключением исключений

0:05:51.757,0:05:59.486
мне было интересно посмотреть сколько выдает openssl

0:06:01.784,0:06:09.251
я думаю этот код показывает максимальные значения, которые способен выдать openssl

0:06:09.251,0:06:17.667
близкий к максимальном, потому что никаких лишних телодвижений и слоев абстракции здесь нет

0:06:18.615,0:06:28.089
пока еще думает, там используется большой блок данных

0:06:31.457,0:06:35.307
при этом

0:06:36.534,0:06:41.666
само приложение я все-таки старые списать в духе ООП

0:06:45.200,0:06:52.340
в духе ООП и в духе тех идей, которые я уже проработал для библиотеки

0:06:54.795,0:06:58.638
есть Sink

0:06:58.638,0:07:01.168
это некий выход

0:07:01.168,0:07:08.400
этот выход 
может быть ничего не делающим

0:07:08.400,0:07:14.479
может шифровать через openssl, может шифровать через мою библиотеку

0:07:18.476,0:07:24.845
тем временем референсное значение мы получили

0:07:30.120,0:07:33.765
это производительность, которую выдает openssl

0:07:33.765,0:07:40.063
это не так уж плохо - 200 мегабит в секунду

0:07:40.063,0:07:52.936
хотя оптимизированные реализации способны выдавать до 800 мегабит в секунду с ядра

0:07:55.359,0:07:58.598
и мне бы очень хотелось обогнать openssl

0:08:03.665,0:08:10.571
давайте посмотрим что получилось при запуске этого теста

0:08:13.655,0:08:20.366
цифра с прозрачным не так высока

0:08:24.961,0:08:28.292
ну бог с ним пока что

0:08:28.292,0:08:34.331
эта цифра не соответствует 
референсной

0:08:34.331,0:08:37.557
потому что здесь мы данные передаем блоками

0:08:37.557,0:08:43.050
если брать один 
большой блок

0:08:43.050,0:08:46.327
то цифры сближаются

0:08:48.467,0:08:53.233
я старался все алгоритмы гонять в одинаковых условных

0:08:53.233,0:08:57.704
и поэтому остановился на такой реализации

0:08:57.704,0:09:02.587
блоки какого-то определенного размера

0:09:04.570,0:09:07.782
гоняются через все три

0:09:07.782,0:09:11.339
здесь интересный 
момент

0:09:13.731,0:09:18.027
в том что этот класс предоставляет Sink'и

0:09:18.656,0:09:22.734
тестирование осуществляется в этом 
классе

0:09:22.734,0:09:26.049
мы можем на него взглянуть

0:09:32.600,0:09:34.855
тут все просто

0:09:36.630,0:09:40.302
берет какие-то данные, пишет их

0:09:40.711,0:09:45.730
и засекает время

0:09:45.730,0:09:50.001
тут можно порассуждать о том

0:09:50.001,0:09:55.350
насколько удобен этот 
интерфейс, это все сделано на скорую руку

0:09:55.350,0:09:58.339
все написано без тестов

0:09:58.339,0:10:01.285
и этом нет большой проблемы

0:10:01.285,0:10:05.318
давайте на этом моменте становимся

0:10:05.318,0:10:13.394
все это приложение - это тест

0:10:13.394,0:10:22.412
он включает в себя разные классы и в принципе их тоже можно было бы потестировать

0:10:22.412,0:10:32.526
Кент Бек говорит о том, что даже 
тестовый код надо тестировать

0:10:32.526,0:10:37.638
но я стараюсь относиться к этому прагматичнее

0:10:37.638,0:10:46.597
и если код боевой или тестовый хотя бы опосредованно тестируются - это уже хорошо

0:10:47.195,0:10:52.585
а тестовый код обычно используется в тестах и так или иначе тестируется

0:10:53.089,0:10:59.626
чтобы писать для него еще 
отдельные тесты которые проверят правильно ли он функционирует в изоляции

0:11:03.434,0:11:12.010
данное приложение само по себе - тест

0:11:12.010,0:11:19.573
основная цель создание этого 
приложения - увидеть вот эту цифру

0:11:19.573,0:11:31.397
Если мы увидели цифру - наша цель достигнута

0:11:36.000,0:11:52.991
мы видим что у нас есть шеститысячекратное замедление наших алгоритмов 
по сравнению с openssl  

0:11:57.240,0:12:04.174
очень большое замедление я понимаю почему 
это происходит

0:12:08.863,0:12:14.470
и мне пока больше не нужно тратить время на этот код

0:12:14.470,0:12:17.629
этот код выполнил 
свою задачу

0:12:17.629,0:12:20.828
это не значит, что его нужно выкинуть (хотя иногда такие одноразовые приложения в agile пишут)

0:12:20.828,0:12:34.016
на данный момент это просто  катастрофический разрыв

0:12:34.016,0:12:41.265
задача номер один это устранить катастрофический разрыв

0:12:43.248,0:12:47.134
и я понимаю откуда 
этот разрыв возникает

0:12:47.606,0:12:56.340
давайте заглянем вот сюда

0:13:00.224,0:13:06.907
а еще заглянем вот сюда

0:13:06.907,0:13:11.770
это мы уже пошли в 
библиотеку

0:13:12.620,0:13:20.218
это класс, который существует базовое криптографическое преобразование

0:13:20.218,0:13:28.231
когда я начинал писать эту библиотеку, это было почти три года назад

0:13:28.231,0:13:33.613
это была первая волна экспериментов с ООП

0:13:33.613,0:13:39.613
я исходил из того, что  во-первых в конструкторе 
не должно быть кода

0:13:39.613,0:13:44.069
у этого класса нет интерфейса

0:13:44.069,0:13:50.312
и это в принципе ошибка

0:13:50.312,0:13:59.275
потому что 
при таком подходе мы натыкаемся на невозможность переопределить этот класс

0:14:02.139,0:14:07.477
по-хорошему это должен быть интерфейс, который состоит из одного метод

0:14:07.477,0:14:11.087
вот из этого

0:14:13.070,0:14:16.541
поясню...

0:14:16.541,0:14:20.061
этот класс осуществляет 
преобразование на ключе

0:14:20.061,0:14:30.000
преобразователь на ключе включает в себя преобразование через ключ

0:14:30.000,0:14:35.045
и преобразование через блок подстановок

0:14:36.910,0:14:47.444
писалось это исходя из того, что все классы должны быть ленивыми

0:14:47.444,0:14:52.889
не должно быть кода в конструкторе

0:14:52.889,0:15:00.360
и ленивость не проблема

0:15:00.360,0:15:06.697
все эти классы ленивые

0:15:06.697,0:15:10.460
ни один из них ничего в конструкторе не делает

0:15:10.460,0:15:15.809
поэтому когда мы передаем сюда строку

0:15:17.225,0:15:25.167
мы натыкаемся на то, что нам нужно из этой строки доставать данные для того чтобы произвести преобразование

0:15:26.646,0:15:30.500
это крайне неоптимальная затея

0:15:30.500,0:15:33.293
поэтому здесь используюется еще дополнительный класс

0:15:33.293,0:15:36.814
который все это кэширует

0:15:36.814,0:15:41.352
что не делает эту затею 
более оптимальный

0:15:41.352,0:15:45.694
все равно это все медленно

0:15:48.401,0:15:53.868
большое количество конструкторов - это 
само по себе не проблема

0:15:53.868,0:15:56.339
но здесь проблема в том, что

0:15:56.339,0:16:06.726
для эффективной работы нам нужно иметь специально подготовленные данные

0:16:06.726,0:16:14.653
причем на вход у нас могут поддаваться данные в разных форматах

0:16:14.653,0:16:21.779
как данные ключа, так и данные блока подстановок

0:16:21.779,0:16:23.876
очень разных форматах

0:16:23.876,0:16:29.160
блок подстановок представляет из себя таблицу четырех-битных значений

0:16:29.160,0:16:36.000
16 на 16, через который осуществляется замена

0:16:36.000,0:16:49.043
пытается производить эти постановки на неправильно подготовленных данных - это крайне неоптимально

0:16:50.207,0:16:56.834
так же не оптимально работать с 
неподготовленными ключевыми данными

0:16:58.187,0:17:02.315
но sbox больше влияет в негативную сторону

0:17:02.315,0:17:08.366
этот код был написан без учета скорости

0:17:08.366,0:17:12.173
Егор Бугаенко почему-то не дооценивает фабрики

0:17:12.173,0:17:20.386
но вот здесь такое место где фабрика крайне необходима

0:17:20.386,0:17:26.848
как раз фабрика могла бы позволить подготовить 
данные для классов

0:17:26.848,0:17:33.246
в оптимальном формате

0:17:35.890,0:17:40.291
но здесь проблема многослойнее

0:17:40.574,0:17:51.242
потому что блочный алгоритм тоже можно оптимизировать по-разному

0:17:51.242,0:18:02.350
проблема в данный доменной области еще более усложняется тем что алгоритм не заканчивается ключем

0:18:07.323,0:18:12.980
если мы используем процессор...

0:18:12.980,0:18:19.958
используется одно оптимальное представление

0:18:19.958,0:18:26.710
если мы используем AVX, то другое

0:18:34.900,0:18:43.870
получается, что исходное представление ключевой информации это отправная точка

0:18:47.426,0:18:53.820
это исходное представление можно было 
инкапсулировать в класс KeyContainer

0:18:55.929,0:19:01.923
ключевой контейнер - это получается очень хорошо, логично

0:19:01.923,0:19:08.815
Из ключевого контейнера мы достаем данные в чистом виде

0:19:08.815,0:19:14.254
возможно в виде массива

0:19:14.254,0:19:18.513
из 8 значений

0:19:18.513,0:19:25.255
и sbox тоже в готовом виде

0:19:26.958,0:19:34.383
в унифицированном виде

0:19:34.383,0:19:42.028
унифицированный вид не является оптимальным для конкретной имплементации

0:19:42.028,0:19:50.963
поэтому для создания ключей

0:19:50.963,0:19:53.833
и конкретных алгоритмов...

0:19:53.833,0:19:58.375
содержимое ключа для ключевого контейнера не секрет

0:19:58.375,0:20:05.846
если мы говорим про ключ - ключ не может отдавать содержимое своих внутренних данных

0:20:05.846,0:20:07.749
потому что это нарушение инкапсуляции

0:20:07.749,0:20:11.950
ключевой контейнер может,
это не нарушение инкапсуляции

0:20:19.902,0:20:24.670
и должно быть фабрика методов

0:20:24.670,0:20:28.723
или несколько фабрик методов, я пока еще не решил

0:20:30.926,0:20:44.349
в нее нужно будет передавать некую стратегию создания имплементаций

0:20:44.349,0:20:48.069
Это может быть стратегия для CPU, для AVX

0:20:48.069,0:20:50.797
исходя из этой стратегии

0:20:50.797,0:20:54.654
сейчас этого здесь не видно, потому что этого пока нет

0:20:56.920,0:21:01.221
исходя из этой стратегии будут создаваться 
ключи

0:21:01.221,0:21:06.082
будут создаваться алгоритмы шифрования

0:21:09.009,0:21:16.237
наиболее оптимально выполняющиеся 
в конкретных условиях

0:21:16.898,0:21:21.260
в первую очередь можно просто разобраться с ключом

0:21:24.250,0:21:27.483
в отличие от простых 
unit тестов

0:21:28.899,0:21:31.242
тест с бенчмарком

0:21:31.242,0:21:34.198
в данном случае он сфейлился

0:21:34.198,0:21:39.229
мы получили крайне несопоставимые цифры

0:21:39.229,0:21:42.509
починить его может быть не так то просто

0:21:44.366,0:21:49.727
я полагаю что это займет некоторое время

0:21:49.727,0:21:55.392
и может быть даже целый релиз библиотеки пройдет, прежде чем эта ситуация как-то изменится

0:21:55.392,0:22:01.082
мне нужно переработать этот класс

0:22:04.796,0:22:11.334
вот этим я и займусь в ближайшее время

0:22:15.142,0:22:18.480
тут еще интересный момент

0:22:19.833,0:22:23.394
это все необходимо делать по шагам

0:22:23.394,0:22:34.058
рефакторинг необходимо 
делать мелкими атомарными шарами

0:22:34.058,0:22:40.911
очень часто сталкиваюсь с тем что люди не понимают как по шагам что-то переделать

0:22:44.373,0:22:47.343
люди любят все сломать

0:22:48.000,0:22:51.341
либо сделать большой коммит

0:22:51.341,0:22:56.543
в которым одна имплементация заменяется на другую имплементацию целиком

0:22:58.305,0:23:04.805
все сломать - какое-то 
время все будет разобрано, но у нас же сейчас не релиз

0:23:06.662,0:23:09.636
к релизу мы все соберем

0:23:11.115,0:23:13.903
так делать категорически нельзя

0:23:15.445,0:23:22.693
поэтому мы будем действовать мелкими атомарными шагами

0:23:22.693,0:23:31.279
и шаг номер один заключается в том что этот класс нужно будет переименовать, чтобы 
освободить имя Key

0:23:31.279,0:23:37.159
имя Key очень хорошо подходит для интерфейса

0:23:38.009,0:23:42.945
для интерфейса, у которого будет много имплементаций

0:23:43.637,0:23:58.443
Егор Бугаенко рекомендует всегда когда ваш объект передается в качестве аргумента - использовать интерфейс

0:23:58.443,0:24:03.050
это очень правильная мысль, поперек которой я в данном случае пошел

0:24:03.050,0:24:06.865
этот класс у меня финальный

0:24:07.557,0:24:10.334
заменить его я не могу

0:24:10.334,0:24:19.123
потому что не приемлю наследование имплементации

0:24:21.295,0:24:26.601
вот с одной стороны это казалось логичным

0:24:28.143,0:24:31.460
но не выдерживает критики стороны производительности

0:24:31.460,0:24:34.664
и вот над производительностью мы сейчас и будем работать

0:24:34.664,0:24:39.903
но с таким расчётом чтобы вопросов к чистоте кода не возникло

0:24:39.903,0:24:42.496
и тут там помогут фабрики

0:24:43.535,0:24:49.321
фабрики делают код таким же чистым

0:24:51.965,0:24:58.757
фабрики вызывают некоторые 
вопросы в плане ООП, потому что у них может не быть состояния

0:24:58.757,0:25:00.904
а может быть

0:25:00.904,0:25:14.914
конкретноые имплементации могут по разному реализовывать поведение объекта

0:25:14.914,0:25:18.752
когда мы говорим про интерфейс

0:25:18.752,0:25:24.962
если для интерфейса применимо понятие геттер

0:25:24.962,0:25:30.806
если сама предметная область подразумевает получение каких-то данных

0:25:30.806,0:25:37.236
это не геттер в плохом 
смысле, в которому его все хают

0:25:37.236,0:25:39.863
это просто такой метод

0:25:39.863,0:25:43.750
который позволяет получить какую-то информацию

0:25:43.750,0:25:47.235
в зависимости от имплементации

0:25:47.235,0:25:53.161
этот метод может возвращать какие-то заранее 
хранящиеся в классе данные

0:25:53.161,0:25:55.772
может генерировать данные

0:25:55.772,0:25:59.745
может формировать эти данные с помощью других объектов

0:25:59.745,0:26:02.296
это не геттер

0:26:05.443,0:26:09.196
различие в имплементациях

0:26:09.196,0:26:11.157
фабрика может не иметь состояния

0:26:11.157,0:26:18.022
но при этом она производит то, что от нее требуется

0:26:19.910,0:26:25.123
может использовать какие-то состояния для производства того, что от нее требуются

0:26:25.123,0:26:30.211
это вопрос имплементации

0:26:31.722,0:26:40.816
как концепция - фабрика вполне себе нормальная идея

0:26:41.635,0:26:47.136
время подходит к концу

0:26:47.136,0:26:55.050
займемся реализацией и через какое-то  время будем делать выпуск номер 2

0:26:55.679,0:26:59.889
оставайтесь с нами до новых встреч


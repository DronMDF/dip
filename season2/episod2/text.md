# Эпизод 2

Мне нужно избавиться от конкретного типа Key, он должен стать абстрактным.
Конкретный тип мешает проводить эксперименты и пробовать разные имплементации.

Для этого мы Key переименовываем в LazyKey (лучше имени не придумал, да оно и не так важно)

Выносить интерфейс и сразу все переводить на новый интерфейс довольно сомнительная идея.
Поэтому мы все делаем по шагам.

1) переименовываем Key в LazyKey
2) Вводим интерфейс Key
3) Пытаемся перевести классы на использование Key...

И тут возникают сложности, потому что за Sink/Source классами скрываются довольно развесистая
иерархия классов Block. Эта иерархия сейчас кажется слишком детальной, и уйдет.

Мне нет смысла приводить эту иерархию в порядок, поэтому переход на новый интерфейс делаем только на
один уровень в глубину. А дальше указатель кастим к конкретному типу, чтобы не переделывать ничего
ниже.

Для проведения экспериментов мы выберем класс ECBSink, чтобы можно было сравнить одну реализацию с
другой. И переработку начнем не с Key, а с алгоритма, который сейчас размазан по иерархии блоков
(Blocks).

Класс, реализующий этот алгоритм не имеет своей идентити.
И такой подход с точки зрения чистого ООП можно посчитать антипаттерном.
Но учитывая что он иммутабельный и финальный - большой проблемы тут нет.
Хотя с названием у меня явно не задалось. EncryptedBase довольно плохое название для класса.
Обычно так называются классы, от которых хотят наследоваться.

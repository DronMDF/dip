Нужно примерно 20 килобайт текста, чтобы сделать выпуск на 25 минут.

# Эпизод 2

В прошлом выпуске мы остановились на том, что на бенчмарках увидели пятикратное падение
производительности по сравнению с реализацией на базе openssl.

Бенчмарки с тех пор немного переработаны, но пятикратное падение по прежнему наблюдается.

Пришла пора заняться оптимизацией и
переработать код так, чтобы он мог сравниться с императивной имплементацией не нарушая при этом
принципов, которых я стараюсь придерживаться.

Мне нужно избавиться от конкретного типа Key, он должен стать абстрактным.
Конкретный тип мешает проводить эксперименты и пробовать разные имплементации.

У Егора Бугаенко на этот счет есть правило, согласно которому все аргументы должны иметь абстрактный
тип. Любой код должен быть тестируемым. Использование конкретных классов препятствует написанию
тестов. У классов могут быть сложные зависимости.

Кроме того, когда мы проводим рефакторинг или работаем над оптимизацией - было бы интересно сравнить
реализацию до и реализацию после. Этого невозможно сделать без абстрактного интерфейса.

Для этого мы Key переименовываем в LazyKey (лучше имени не придумал, но это не должно меня
останавливать)

Пытаться все сделать сразу - довольно сомнительная идея.
Поэтому мы все делаем по шагам.

В этом плане очень полезна книга Фаулера - Рефакторинг.
Даже если вы не будете делать настолько атомарные коммиты, нужно уметь видеть места, в которых
система стабильна.

1) переименовываем Key в LazyKey

2) Вводим интерфейс Key

3) Пытаемся перевести классы на использование Key...

И тут возникают сложности, потому что за Sink/Source классами скрываются довольно развесистая
иерархия классов Block. Эта иерархия сейчас кажется слишком детальной, и уйдет.

Мне нет смысла приводить эту иерархию в порядок, поэтому переход на новый интерфейс делаем только на
один уровень в глубину. А дальше указатель кастим к конкретному типу, чтобы не переделывать ничего
ниже.

Для проведения экспериментов мы выберем класс ECBSink, чтобы можно было сравнить одну реализацию с
другой. И переработку начнем не с Key, а с алгоритма, который сейчас размазан по иерархии блоков
(Blocks).

Класс, реализующий этот алгоритм не имеет своей идентити.
И такой подход с точки зрения чистого ООП можно посчитать антипаттерном.
Но учитывая что он иммутабельный и финальный - большой проблемы тут нет.
Хотя с названием у меня явно не задалось. EncryptedBase довольно плохое название для класса.
Обычно так называются классы, от которых хотят наследоваться.

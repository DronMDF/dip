0:00:00.000,0:00:13.500
возвращаемся к библиотеке goost

0:00:13.500,0:00:23.940
Я открыл для 
себя githib cli,

0:00:23.940,0:00:25.940
довольно интереснуая штука

0:00:29.500,0:00:33.760
для открытых проектов я стараюсь использовать github
и все время приходилось заходить  
в браузер

0:00:33.760,0:00:43.390
сделать пулл-реквест, еще что-то 
сейчас его можно сделать отсюда 

0:00:43.390,0:00:49.420
ну, основные  вещи можно сделать отсюда. Я например 
не нашел возможности модифицировать ишью

0:00:49.420,0:01:00.775
довольно странно. Но возможно они это еще доработают 
систему.  

0:01:00.775,0:01:16.360
И чтобы эта штука смогла заменить мне тудушку, мне необходимо иметь возможность 
выставлять какие-то приоритеты для себя

0:01:16.360,0:01:27.856
я не разделяю представление о том что там 
все задачи до одной в беклоге должны быть  приоритезориваны

0:01:27.856,0:01:30.970
мне достаточно более 
простого подхода 

0:01:30.970,0:01:36.008
когда я на ближайшую  перспективу отмечаю для себя себе какой-то
ограниченный набор задач 

0:01:36.008,0:01:42.624
себе либо своей команде и занимаюсь этими задачами

0:01:42.624,0:01:52.938
то 
есть гитхабе это можно сделать через теги вот я отметил парочку задач которые хотел решить 
в первую очередь

0:01:52.938,0:01:55.496
почему именно эти задачи

0:01:55.496,0:02:09.995
библиотек не получается разрабатывать на 
голом месте я начинал как раз разрабатывать все таким образом и уперся в то 
что я не понимаю как это должно  быть

0:02:09.995,0:02:17.217
пока у меня не период приложение 
которое эти возможности использует

0:02:17.940,0:02:24.420
вот и все что я здесь пишу я обкатываю на приложение

0:02:32.000,0:02:42.380
казалось бы шифрование мы сделали в прошлый 
раз и было бы логично сделать имитовставку 

0:02:42.380,0:02:46.054
потому что  шифрование мид отставка обычно ходят 
рядом

0:02:46.054,0:02:52.627
но имитовставка в каком-то виде у меня есть. Она написане так, как я сейчас хочу,
но при этом оно работает

0:02:52.627,0:03:00.000
имеет смысл использовать тот ход который работает

0:03:00.176,0:03:03.948
но мне 
не хватает расшифрования 

0:03:03.948,0:03:10.174
поэтому сейчас мы зовёмся расшифрованием чтобы мое приложение 
заработало 

0:03:10.174,0:03:17.650
 когда приложение заработает можно будет строить планы по дальнейшему 
усовершенствованию этой библиотеки

0:03:17.650,0:03:22.770
и поэтому мы сейчас сделаем расшифрование 

0:03:22.770,0:03:32.116
за одно до позволит  обкатать концепцию source чуть более глубоко

0:03:39.560,0:03:50.000
я сделал небольшой набросок, 
начнем мы конечно с теста

0:04:07.330,0:04:20.080
так нормально дескрипшин? а данные мы будем 
брать из теста на шифрование  

0:04:20.080,0:04:27.340
только мы переворачиваем. вот у нас есть 
исходный блок данных 

0:04:27.340,0:04:35.760
этот блок данных заворачивается в Source

0:04:46.820,0:04:55.284
но одних данных недостаточно нам 
необходимо передать сюда еще ключ

0:04:56.914,0:05:03.579
и вектор инициализации

0:05:13.660,0:05:17.985
и все это

0:05:20.740,0:05:24.257
нужно завернуть в Text

0:05:26.980,0:05:32.770
должен быть такой класс, который преобразует это в текст

0:05:49.110,0:05:57.647
в плане сравнения у меня уже все что 
нужно есть. SourceMatch 

0:05:57.647,0:06:06.593
и у меня есть  расшифрованные данные, которые должны совпасть

0:06:14.546,0:06:18.125
это все

0:06:18.125,0:06:25.076
здесь не хватает 
инклюдов, но давайте действовать по порядку

0:06:30.580,0:06:35.304
действуем с упором на компилятор

0:06:41.010,0:06:43.020
копипаста детектед

0:06:55.068,0:07:01.406
она ругается, потому что я не делаю using namespace

0:07:01.406,0:07:07.302
для с++ файлов делаем сразу

0:07:08.155,0:07:13.932
про namespace я думаю 
по-разному

0:07:13.932,0:07:20.393
здесь их кажется довольно много

0:07:23.496,0:07:27.551
это может напрягать

0:07:27.551,0:07:34.660
но при этом в библиотеке 
namespace наверное полезны

0:07:34.660,0:07:41.793
особенно в библиотеке, которую я предполагаю отдать сообществу

0:07:41.793,0:07:46.990
потому что люди будут использовать библиотеку и я бы не хотел чтобы они натыкались на мои определения

0:07:46.990,0:07:51.095
на конфликт моих определений со своими

0:07:51.095,0:07:56.499
при этом я замечаю, что некоторые люди в приложениях 
начинают использовать namespace

0:07:56.770,0:08:00.832
этого делать не стоит

0:08:06.960,0:08:13.408
он говорит, что у меня нет SourceText

0:08:19.030,0:08:24.000
есть SourceText, я его уже сделал

0:08:24.000,0:08:29.115
просто его нужно заинклюдить

0:08:34.300,0:08:39.349
И Hex64Source у меня уже есть

0:08:43.887,0:08:47.904
А CFBSource?...

0:08:58.820,0:09:07.505
CFBSource у меня на самом деле тоже уже есть

0:09:08.242,0:09:13.132
надо писать goost

0:09:15.132,0:09:18.490
тут надо написать test

0:09:26.410,0:09:28.390
тут надо написать

0:09:41.170,0:09:47.245
для тестирования мы используем только goost::magma

0:09:51.710,0:09:54.756
проверяем...

0:09:54.756,0:09:58.255
я заинклюдил?...

0:09:59.580,0:10:04.184
Да, я заинклюдил,

0:10:05.930,0:10:11.116
но здесь еще ничего не написал

0:10:21.975,0:10:25.228
мы делаем только устранение ошибок

0:10:25.228,0:10:29.071
вот она говорит -
не могу найти класс

0:10:29.071,0:10:34.232
...смогла найти класс

0:10:34.232,0:10:37.565
но после этого возникнут другие проблемы

0:10:37.565,0:10:42.919
не может найти Key, говорит она

0:10:42.919,0:10:45.822
это мы идем сюда и пишем...

0:10:52.400,0:10:54.335
Key

0:10:57.650,0:11:01.840
смогла найти Key

0:11:01.840,0:11:06.389
теперь у неё в 38 строке возникла какая-то проблема

0:11:06.389,0:11:08.423
запятая лишняя

0:11:08.423,0:11:11.427
запятую убираем

0:11:14.918,0:11:24.021
еще что-то лишнее, SourceMatch не определён

0:11:29.303,0:11:32.718
порядок нарушился

0:11:32.718,0:11:35.689
Все определения лучше делать в алфавитном порядке

0:11:35.689,0:11:41.589
потому что когда мёржатся ветки, а в списке инклюдов кто-нибудь покопался

0:11:41.589,0:11:45.325
бывают 
возникают дублирования

0:11:45.325,0:11:48.445
и всякое такое

0:11:54.242,0:11:59.641
в 52 строке ошибка

0:12:01.130,0:12:04.295
Что это интересно, ей не понравилось?

0:12:04.295,0:12:08.095
где-то скобки забыл?

0:12:13.930,0:12:17.828
вроде все скобочки на месте

0:12:20.170,0:12:24.100
стоп, а это я откуда скопировал?

0:12:26.086,0:12:29.866
это опять copy-paste

0:12:33.970,0:12:40.493
вот такие сообщение не люблю ни черта 
не понятно, надо с конца смотреть

0:12:41.230,0:12:46.900
он хочет сказать... где-то здесь

0:12:55.220,0:13:02.060
он хочет сказать что абстрактный 
метод не может существовать

0:13:35.584,0:13:39.300
За 100 символов заходит, безобразие

0:13:39.300,0:13:41.774
очени не люблю заходить за 100 символов

0:13:41.774,0:13:46.690
но у меня сейчас линтер не работает, поэтому можно

0:13:48.552,0:13:53.122
как бы я это исправил?

0:13:53.122,0:13:56.512
я бы исправил это вот так

0:14:11.650,0:14:17.429
сейчас у меня должна возникнуть другая ошибка, видимо

0:14:17.429,0:14:24.097
теперь у меня возникла ошибка, что нет такого конструктора

0:14:31.894,0:14:47.207
здесь лучше заглянуть в CFBSink, потому что они похожи, немного...

0:15:01.790,0:15:05.692
это primary конструктор, а вот у нас secondary конструктор

0:15:05.692,0:15:08.720
вот мы сейчас хотим secondary пока что

0:15:23.729,0:15:27.650
почему мы хотим secondary? потому что

0:15:27.650,0:15:32.640
primary конструктор содержит большее количество аргументов

0:15:32.640,0:15:36.546
и понадобится нам чуть позже

0:15:39.690,0:15:44.739
тут уже куча ошибок полезла

0:15:47.510,0:15:52.568
она говорю что не знает такого слова

0:15:57.611,0:16:06.173
так можно написать? не красиво наверное (и не нужно)

0:16:17.560,0:16:20.243
уже почти все скомпилировалось

0:16:20.243,0:16:23.500
но теперь 
она ругается на отсутствие имплементации

0:16:32.484,0:16:37.234
У меня есть небольшая заготовочка

0:16:50.000,0:16:53.610
делаем пока два метода

0:17:07.460,0:17:11.180
если мы оставим так, будет куча ругани

0:17:39.820,0:17:42.190
override здесь не нужен

0:18:00.070,0:18:02.437
так скомпилит?

0:18:02.437,0:18:05.081
а так видимо ругнется

0:18:05.081,0:18:08.128
давайте посмотрим 
как ругнется

0:18:09.175,0:18:13.417
не ругнулась, потому что я не включил...

0:18:20.150,0:18:23.020
umagma, magma

0:18:32.840,0:18:36.812
вот теперь мы видим кучу ошибок

0:18:37.316,0:18:40.231
unused parameters

0:18:46.224,0:18:50.754
чтобы убрать unused parameters давайте просто заюзаем их

0:18:54.129,0:19:00.755
это будет проще, мы избежим промежуточных шагов

0:19:15.434,0:19:20.744
после этого она конечно ругнется  что у нас таких параметров нет

0:19:20.744,0:19:25.950
давайте тоже 
сразу предупредим и опишем их

0:19:49.532,0:19:54.916
это все еще пока сыро

0:19:54.916,0:20:00.769
что-то ей не нравится

0:20:16.350,0:20:19.110
здесь нужен Source

0:20:31.560,0:20:33.349
вот-так станет лучше?

0:20:33.349,0:20:37.628
нет, не станет лучше...

0:20:39.257,0:20:42.931
потому, что она не может его найти

0:20:42.931,0:20:44.931
вот так вот

0:20:46.771,0:20:52.386
теперь она смогла его найти... что такое c size?

0:20:52.386,0:20:57.239
она говорит, что это unused parameter, блин

0:21:00.575,0:21:04.209
добавим вектор

0:21:08.476,0:21:11.153
чтобы как-то использовать параметр

0:21:11.153,0:21:14.338
это конечно 
полнейшая хрень

0:21:15.347,0:21:18.656
но мы можем запустить тест

0:21:22.535,0:21:26.345
и ничего не умерло, потому, что...

0:21:26.345,0:21:31.297
потому, что мы не
включили тест в набор, это кстати важный момент

0:21:48.250,0:21:51.820
мы только что протестировали этот кейс, грубо говоря

0:21:58.570,0:22:02.140
протестировали тот факт, что наш тест вызывается

0:22:13.196,0:22:16.417
что-то криво написал...

0:22:30.974,0:22:37.934
и все умерло... как это выглядит?

0:22:50.780,0:22:51.280
а

0:22:53.790,0:22:54.930
потому что

0:22:59.620,0:23:04.270
потому что чтобы прочитать из неизвестного 
источника я читаю все что там есть 

0:23:07.179,0:23:10.436
и  естественно что не можете создать вектор такого 
размера

0:23:10.436,0:23:14.331
значит пора писать имплементацию

0:23:14.680,0:23:17.249
прошло 15 минут...

0:23:18.025,0:23:21.565
и конечно это не заработает наверное

0:23:41.640,0:23:45.249
так что тут у нас у нас

0:23:45.760,0:23:48.988
у нет слова plain

0:23:49.770,0:23:53.010
вот у нас определился primary конструктор

0:23:57.820,0:24:02.402
у нас может быть уже какое-то количество количество расшифрованных данных

0:24:02.402,0:24:08.620
которые еще никто не забрал

0:24:20.950,0:24:22.780
это мы положим сюда

0:24:31.376,0:24:33.111
всё const

0:24:33.111,0:24:36.206
всё должно быть const

0:25:10.816,0:25:16.942
понятно, что все алгоритмы тестировать 
в разных условиях

0:25:16.942,0:25:21.039
я реально смотрю один кейс

0:25:38.890,0:25:42.790
здесь всё можно немного пересмотреть, наворочанно получилось

0:25:47.382,0:25:49.692
так что там еще нам мешает?

0:26:08.390,0:26:12.799
теперь нам нужны примитивчики

0:26:15.475,0:26:21.986
и BlkEncrypted

0:26:33.570,0:26:36.210
BlkEncrypted, все правильно, это же гаммирование

0:27:04.256,0:27:09.256
что там он еще не знает?

0:27:18.560,0:27:22.607
там не было необходимости сравнения, а здесь есть

0:27:23.228,0:27:26.621
мне сейчас довольно сильно мешает этот дурацкий Block

0:27:33.030,0:27:35.220
неожиданно все скомпилировалось

0:27:42.300,0:27:43.110
out of range

0:27:52.802,0:27:58.352
у меня возникла проблема с тестированием

0:28:08.490,0:28:10.740
потому что этот класс...

0:28:19.420,0:28:24.023
хорошо бы тест написать

0:28:24.488,0:28:26.911
но я сейчас ленюсь

0:28:32.496,0:28:35.150
прошло 15 минут

0:28:36.906,0:28:40.669
это мы забиваем буфер

0:28:41.639,0:28:45.213
а размер должен быть кратен 8

0:29:25.447,0:29:28.657
как по английски слово кратен?

0:30:11.550,0:30:18.953
это конечно неправильное слово, ну ладно

0:30:45.659,0:30:48.554
все тесты прошли

0:30:48.554,0:30:51.848
включая будет тест на гост

0:30:51.848,0:30:53.371
да?

0:30:56.978,0:30:58.632
давай проверим

0:31:06.079,0:31:14.487
нужно просто вставить туда какую-нибудь

0:31:24.090,0:31:27.871
сейчас у нас один тест должен упасть

0:31:28.065,0:31:31.151
один тест упал

0:31:33.600,0:31:37.450
все хорошо

0:31:38.791,0:31:43.510
значит проблема была с HexSource

0:31:49.493,0:31:55.886
на этом мы закрыли 407 тикет

0:32:20.800,0:32:29.578
и хотелось бы устроить разбор полетов

0:32:47.251,0:32:53.246
я в начале скринкаста говорил о том,

0:32:54.293,0:32:59.648
что не стоит делать то, что не требуется непосредственно сейчас

0:32:59.648,0:33:07.293
например имитовставка у меня есть и ее не нужно перерабатывать, поскольку 
она работает

0:33:13.460,0:33:23.036
вот а здесь здесь я довольно сильно зарылся в имплементацию 
пытался учесть всякие корнер кейсы

0:33:29.120,0:33:32.466
при том у меня всего один тест

0:33:32.466,0:33:37.717
во первых, сомнительно что он все покрываетвсе

0:33:38.997,0:33:44.202
он точно все не покрывает потому 
что шифрует блоками фиксированной длины

0:33:44.202,0:33:48.995
если шифровать по байтику, по три байтика

0:33:48.995,0:33:53.017
как оно будет? нужны новые тесты

0:33:54.646,0:34:00.736
и встает вопрос зачем мы все это 
писали если мы не уверены в том, что это работает?

0:34:02.869,0:34:05.950
в следующий раз надо себя сдерживать

0:34:05.950,0:34:13.652
на этом всё. прощаюсь, заканчиваю, до новых встреч


0:00:00.000,0:00:05.666
сегодня записываюсь в необычных 
условиях

0:00:05.666,0:00:11.914
выдался свободный час
и этот час я провожу в машине

0:00:11.914,0:00:21.359
поэтому на фоне могут слышаться посторонние звуки 
постараемся вычистить посмотрим что получится

0:00:21.359,0:00:28.829
задача сегодня все также 
связано с goost

0:00:28.829,0:00:33.413
эта библиотека который занимается шифрованием

0:00:33.413,0:00:38.826
ну будет когда-нибудь 
заниматься шифрованием хорошо, а пока это прототип

0:00:38.826,0:00:42.805
для того чтобы обкатать 
некоторые идеи

0:00:42.805,0:00:51.554
вот и мне сейчас не хватает  режима простой замены 

0:00:51.554,0:00:54.831
простая замена 
довольно тривиальная вещь

0:00:54.831,0:01:00.079
и поэтому я думаю что шифрование расшифрования можно 
будет сделать сразу

0:01:00.079,0:01:05.900
но прежде чем этим заняться я задумал небольшой рефакторинг

0:01:05.900,0:01:14.143
у меня в тестах не очень удобно использовать Sink

0:01:14.143,0:01:19.975
Sink, напомню, это такой объект для вывода информации

0:01:19.975,0:01:26.944
его не удобно использовать потому, что сейчас

0:01:26.944,0:01:31.457
в каждом месте используется свой Sink

0:01:31.457,0:01:44.846
поэтому надо сделать небольшой рефакторинг, чтобы этот этот код можно было описать один раз 

0:01:44.846,0:01:49.727
как это не хватает code reuse

0:01:49.727,0:01:54.842
этим мы сперва и займемся

0:02:04.140,0:02:07.313
есть первый класс

0:02:07.313,0:02:13.620
Вот наш 
тест в котором описан этот SinkText

0:02:19.630,0:02:27.469
но учитывая что в абстрактном Sink у нас есть метод finalize

0:02:27.469,0:02:31.751
который возвращает нижележащий Sink

0:02:31.751,0:02:34.936
я могу 
этот класс сделать абстрактным

0:02:34.936,0:02:37.193
могу сказать

0:02:37.193,0:02:44.021
TestSinkText

0:02:44.021,0:02:49.826
который из какого-то Sink'а, неизвестного нам

0:02:49.826,0:02:56.372
пропишет в него данные и вытащит нижележащий Sink

0:02:56.372,0:03:03.312
из которого можно будет достать данные в виде текста

0:03:03.312,0:03:14.205
при этом класс который 
мы тестируем мы сможем создать в тесте, что правильно

0:03:14.535,0:03:20.890
давайте наметим

0:04:02.900,0:04:14.678
это нужно для того, я сейчас собираюсь писать режим простой замены и мне там тоже понадобится тестировать Sink

0:04:16.800,0:04:30.362
и тестировать Sink - мне неудобно каждый раз писать собственную имплементацию текста

0:04:38.800,0:04:45.606
что-то я разошелся... 

0:04:47.586,0:04:55.630
все правильно сделал, так... 

0:05:47.392,0:05:53.731
здесь текст нужен без неймспейсов, вроде

0:05:57.220,0:06:08.876
если мы что-то используем из библиотеки нам 
нужно написать форвард декларацию 

0:06:26.880,0:06:29.820
хорошо

0:06:48.290,0:06:53.707
забыл, надо linter сделать, чтобы он контролировал

0:06:54.179,0:06:59.819
всегда в инклюдах 
надо ставить #pragma once

0:07:17.040,0:07:22.323
а еще забыл...

0:08:35.594,0:08:44.212
это очень важно - добиваться возможности повторно использовать код

0:09:16.440,0:09:22.645
если вдруг программист ошибеться и подсунет мне какой-то Sink

0:09:22.645,0:09:27.305
который не имеет на нижнем ярусе TestSink

0:09:27.305,0:09:37.077
то будет ошибка dynamic_cast
это было бы интересно посмотреть
может быть увижу при случае

0:10:37.521,0:10:44.451
здесь больше ничего не надо менять

0:10:44.451,0:10:51.468
этот класс нам не нужен, мы его убираем

0:12:20.930,0:12:25.765
короткий комментарий

0:12:37.050,0:12:40.442
так попробуем собраться

0:12:50.980,0:12:55.883
я не добавил memory

0:13:01.760,0:13:07.490
стало чуть чище 

0:13:18.520,0:13:20.260
и также Sink

0:13:34.620,0:13:39.112
и TestSink надо добавить

0:14:32.380,0:14:34.450
работает

0:14:48.950,0:14:54.783
также убираем отсюда - дублирование у нас было

0:15:50.370,0:15:58.570
не знаю насколько хорошо  требовать

0:15:58.570,0:16:09.060
здесь есть какая-то архитектурная проблема 
я требую чтобы использовались определенные, необходимые мне зависимости

0:16:38.479,0:16:43.142
больше я не вижу таких проблем

0:16:49.494,0:16:57.354
можно коммитить

0:17:05.490,0:17:07.410
запрос 423

0:17:38.640,0:17:43.693
пусть пока собирается

0:17:44.460,0:17:49.187
а мы займемся ECB

0:17:49.187,0:17:55.695
и для ECB надо надо полезть и 
стандарт

0:18:09.240,0:18:14.199
находим тесты для магмы

0:18:14.199,0:18:20.730
64 битные

0:18:27.769,0:18:32.359
вот же оно

0:18:41.279,0:18:44.729
и начинаем с теста

0:20:16.620,0:20:22.473
не так давно думал про линтеры

0:20:22.473,0:20:31.855
тест выглядит 
довольно большим

0:20:31.855,0:20:40.046
и это может быть проблемой, но тут нужно 
понимать что это не код

0:20:40.046,0:20:42.154
это инициализация

0:20:42.154,0:20:48.704
хотя в с++ сейчас так намешано что инициализация и 
код это одно и то же

0:20:52.759,0:21:01.842
надо убрать лишние определения

0:21:38.239,0:21:44.299
механизм ровно тот же самый

0:21:45.619,0:21:48.727
ключ у нас тот же самый

0:21:48.727,0:21:54.640
вектора инициализации в этом режиме нет

0:21:54.640,0:22:01.698
так и данные нас открытые - те же самые

0:22:01.698,0:22:06.705
а закрытые данные у нас другие

0:22:13.560,0:22:22.500
сейчас мы дойдем имплементации и я расскажу 
о своих идеях по оптимизации

0:22:50.410,0:22:54.344
сейчас я не планирую заниматься 
оптимизацией

0:22:54.344,0:23:01.870
у меня задача - заставить это работать

0:23:19.800,0:23:25.080
поэтому я добавляю нужны мне алгоритмы

0:23:28.286,0:23:35.201
не особо заморачиваюсь о том насколько 
быстро они работают

0:23:35.201,0:23:40.916
хотя это конечно важно

0:23:54.410,0:23:57.024
это весь тест.

0:24:31.640,0:24:37.477
сейчас конечно будет ошибка ошибка 
будет в том что у нас такого файла

0:25:05.530,0:25:10.961
код такой длинный, потому что эти CFB и у него состояние

0:25:10.961,0:25:13.836
У ECB состояния нет

0:25:20.200,0:25:26.082
ECB так устроен...

0:25:36.030,0:25:52.256
мы можем 
сделать, чтобы писать в него по частям а он будет 
в нижележащей поток выпихивать только то что уже зашифрованно

0:25:52.256,0:25:55.665
метод finalize становится 
оправданным

0:25:55.665,0:25:59.268
но пока мы не будем так заморачиваться

0:26:00.258,0:26:06.547
так вот во втором случае нам потребуется 
какое-то состояние

0:26:07.584,0:26:10.850
в простом случае никакого состояния нам не требуется

0:26:10.850,0:26:16.818
мы начинаем с 
простого случая а усложнять будем только если будет нужно

0:26:19.694,0:26:24.541
я в прошлый раз с гаммированием сильно усложнил

0:26:24.541,0:26:29.830
пытаясь проработать граничные случаи,
которые у меня тестами не покрыты
так делать нельзя

0:26:43.040,0:26:45.316
здесь очень много кода

0:26:59.739,0:27:06.440
ECB это один из немногих алгоритмов которые можно эффективно распараллелить

0:27:06.440,0:27:10.205
правда с другой стороны он используется реже

0:27:12.232,0:27:17.764
он не такой стойкий как гаммирование

0:27:19.037,0:27:23.563
поэтому используется не так активно

0:27:58.299,0:28:06.249
оставим этот кусок как есть

0:29:19.572,0:29:25.490
здесь интересно, потому что...

0:29:25.490,0:29:29.305
придется писать два раза

0:29:29.305,0:29:32.863
и не будем заморачиваться напишем два раза

0:29:32.863,0:29:38.138
я кажется говорил, 
что производительность
меня пока вообще не волнует

0:29:47.380,0:29:54.576
всеравно не могу писать два раза, потому что мне нужен на вход вектор

0:29:58.772,0:30:05.406
и я могу использовать p,
хотя это и некрасиво

0:30:32.180,0:30:36.320
но о том что красиво, а что некрасиво можно подумать потом  

0:30:36.320,0:30:43.777
я знаю, что размер p у меня достаточный

0:30:53.631,0:31:00.000
и вот здесь нужно ругнуться

0:31:00.000,0:31:08.522
поскольку мы не прорабатываем все углы

0:31:19.910,0:31:28.310
мы должны сделать так чтобы кто-то не попытался эти углы эксплуатировать

0:31:28.310,0:31:33.313
эти corner cases не закрыты

0:31:33.502,0:31:39.046
поэтому мы просто бросаем исключение

0:31:46.520,0:31:52.541
бросили исключение

0:31:52.541,0:31:55.286
создали новый 
новый Sink

0:31:55.286,0:32:00.959
а finalize у нас вообще ничего не делает

0:32:09.810,0:32:13.017
вот в таком виде должно работать

0:32:13.017,0:32:15.721
но я не договорил про оптимизацию

0:32:15.721,0:32:23.323
этот класс - хороший вариант для для sse оптимизацией

0:32:23.323,0:32:30.324
потому что блоки можно шифровать в параллель

0:32:30.324,0:32:33.657
если вдруг на вход подано много 
данных

0:32:37.193,0:32:42.726
но я пришел к выводу

0:32:42.726,0:32:49.002
что использовать при этом абстрактный ключ все равно не получится

0:32:49.002,0:32:58.553
поскольку нас ключ будет завязан на размер блока данных с которым мы оперируем

0:32:58.553,0:33:04.320
этот размер 
зависит от того какой алгоритм мы применяем

0:33:06.395,0:33:11.936
и получается что вот эти классы

0:33:11.936,0:33:17.105
тоже будут 
зависеть от алгоритма который мы применяем

0:33:18.802,0:33:25.444
вот и получается что у меня будет несколько 
семейств алгоритмов

0:33:26.151,0:33:31.186
несколько семейств режимов блочных преобразований

0:33:31.186,0:33:35.488
для каждого алгоритм оптимизации свой

0:33:35.488,0:33:41.107
если это generic, у меня будет genericECB

0:33:41.107,0:33:48.054
если я делаю SSE, е у меня ECBsse

0:33:49.232,0:33:51.224
и так далее...

0:33:51.224,0:33:53.375
и чтобы всем этим удобно было пользоваться

0:33:53.375,0:33:59.423
надо будет cделать какую-то фабрику

0:34:06.096,0:34:10.935
которая будет генерировать Sink, Source

0:34:10.935,0:34:16.171
и из того ключевого материала и по тому алгоритму, который нам нужен

0:34:17.538,0:34:21.735
продолжаем

0:34:24.894,0:34:34.176
так чего не хватает, забыл переименовать

0:35:10.220,0:35:13.900
сейчас я продолжаю в более комфортных условиях
(хотя звук получился хуже :facepalm:)

0:35:13.900,0:35:26.138
и с момента последней записи 
мне в голову пришла мысль

0:35:43.410,0:35:47.079
тест не включил

0:36:02.280,0:36:06.532
сейчас мы доведем тест до ума

0:36:38.640,0:36:42.840
плохо, что ничего не сломалось,
желательно посмотреть как это падает 

0:36:43.359,0:36:47.677
будем считать чудом

0:37:14.578,0:37:19.980
если рассуждать о разных оптимизациях

0:37:23.469,0:37:26.981
часть алгоритма у нас зарыта в ключе

0:37:26.981,0:37:31.198
блочные преобразования зарыты в ключе

0:37:31.480,0:37:38.452
но если мы соберемся переписывать этот код на SSE

0:37:38.452,0:37:42.114
их нас изменится интерфейс Key

0:37:42.114,0:37:46.139
он станет шире, не на один блок а на 4 блока

0:37:46.139,0:37:54.166
и неизбежно изменится 
этот алгоритм, потому что он станет работать по другому

0:37:55.533,0:38:03.135
Ну CFB плохо паралелится, а например ECB паралелится хорошо

0:38:03.135,0:38:07.817
этот алгоритм станет работать с другими типами

0:38:15.926,0:38:22.115
получается, что у нас целое семейство классов

0:38:22.115,0:38:26.780
ключи, Source и Sink

0:38:26.780,0:38:31.498
они будут относиться к разным типам оптимизации

0:38:31.498,0:38:35.723
либо дженерик имплиментация, либо SSE, AVX

0:38:35.723,0:38:39.997
и так далее
это три разных набора классов

0:38:39.997,0:38:48.102
на других платформах могут быть свои векторизации

0:38:53.920,0:38:57.661
и получается

0:39:00.254,0:39:06.412
что пользователю надо 
предоставлять какой-то фасад

0:39:06.412,0:39:09.950
через который он сможет выбрать нужный ему алгоритм

0:39:09.950,0:39:14.439
не попал горит 
не будет выбран с учетом особенности платформы

0:39:17.032,0:39:24.013
то есть нужна фабрика 
для алгоритмов ввода-вывода

0:39:30.120,0:39:34.007
это только начало мысли

0:39:34.007,0:39:43.294
здесь очень много плясок вокруг того, что данные могут передаваться неровными кусками

0:39:43.294,0:39:49.734
пользователь захотел один байтик, мы ему один байтик как-то пытаемся организовать

0:39:49.734,0:39:53.183
довольно неудобно

0:39:53.183,0:40:01.126
и в том случае если мы спрячем все это за фабрикой

0:40:01.126,0:40:14.717
мы сможем создавать не один объект, а композицию объектов с нужными характеристиками

0:40:14.717,0:40:27.474
это позволит разделить имплементацию гаммирования от имплементации работы с невыровненными данными

0:40:27.474,0:40:34.014
работа с невыровненными данными будет реализована один раз для всех алгоритмов

0:40:34.014,0:40:41.314
алгоритм гаммирования для каждой оптимизации будет разный

0:40:44.662,0:40:52.921
это возможность появляется благодаря тому что 
мы прячем процесс создания объекта за фабрикой

0:40:56.410,0:41:01.702
довольно прикольный момент 
осознания ценности паттернов

0:41:36.200,0:41:42.434
для полноты сделаем обратный процесс - расшифрования

0:45:25.880,0:45:29.750
возвращаюсь к той мысли, 
которая меня посетила

0:45:36.210,0:45:41.806
нам не нужно делать этот код сложным

0:45:43.551,0:45:48.971
может быть даже не нужно хранить промежуточных состояний

0:45:52.460,0:46:00.409
этим сможет заниматься другой класс, который будет стоять сверху

0:46:33.670,0:46:40.189
хотя с Source тут может быть некоторая проблема  

0:46:40.189,0:46:52.271
которая заключается в том что я пока не заложил метод для получения нижележащего Source

0:46:52.742,0:47:00.220
при работе с неровными данными нижележащий Source будет ломаться

0:47:18.330,0:47:23.983
абстракции бывает, что текут
с этим ничего не поделаешь

0:48:32.630,0:48:35.900
можно работать только по 8 байт

0:48:57.331,0:49:04.144
если за количеством байт следит верхний уровень

0:49:05.889,0:49:15.943
зная особенности алгоритма мы можем запрашивать из него данные такими  порциями, какими это удобно

0:49:15.943,0:49:23.100
generic будет читать по 8 байт, sse по 32

0:49:26.212,0:49:39.682
пользователь может запрашивать по 1 байту, но ECB не может расшифровать 1 байт  

0:49:39.682,0:49:44.806
а вернуть 1

0:49:44.806,0:49:53.255
но что делать с остальными байтами этот вопрос ведь это скорее всего 
ошибка

0:49:53.255,0:49:59.523
и вышестоящий уровень в состоянии это отследить

0:49:59.523,0:50:03.495
осталось 7 байт,  которые я 
не могу провернуть назад

0:50:04.721,0:50:07.766
все логично

0:50:11.510,0:50:23.802
а если пользователь хочет 100 байт, то можно на оптимизированном алгоритме запрашивать блоки максимального размера  

0:52:14.800,0:52:20.372
сломалась - хорошо.
значит тест работает

0:52:27.680,0:52:29.720
не хватает

0:52:52.960,0:52:58.600
слишком много кода...

0:53:08.910,0:53:12.360
вышестоящий уровень будет заниматься оптимизацией

0:53:33.480,0:53:37.890
не надо пытаться делать таких вещей, это плохо

0:53:53.620,0:53:55.660
вот так это должно быть, проще

0:54:12.540,0:54:17.245
хорошо, теперь нет segmentation fault

0:54:17.245,0:54:24.660
чтобы тест сошелся
надо добавить еще одну штуку

0:54:43.350,0:54:45.266
нет, стоп

0:54:52.560,0:54:58.046
надо SourceText переработать, чтобы он высасывал столько, сколько надо

0:55:50.850,0:55:55.487
сейчас наверное все попадает

0:55:55.487,0:56:00.744
просим максимум,
получаем сколько-то

0:56:00.744,0:56:04.702
это нормальное поведения для Source

0:57:15.040,0:57:19.240
по пустоте определяем конец потоку?
пусть будет так

0:58:30.678,0:58:34.774
ничего не упало, на удивление  

0:58:43.670,0:58:48.733
на этом можно остановиться на сегодня

0:58:48.733,0:58:55.206
вопросы оптимизации я сейчас специально не заморачиваюсь, я бью себя по рукам, чтобы не делать оптимизацию

0:58:55.206,0:58:58.576
не надо смешивать функционал с оптимизацией

0:58:58.576,0:59:02.391
оптимизацию надо делать  целенаправленно

0:59:02.391,0:59:08.425
и как видите вскрываются всякие дополнительные пласты

0:59:08.425,0:59:14.252
до этого я думал что мне нужен абстрактный ключ

0:59:14.252,0:59:18.879
а сейчас я уже не уверен, что мне нужно именно это

0:59:25.670,0:59:29.788
мне нужно несколько абстрактных ключей!

0:59:36.670,0:59:44.989
у каждого семейства алгоритмов будет внутренний тип ключа

0:59:47.299,0:59:53.697
а сами ключи будут происходить 
из контейнеров

1:00:01.080,1:00:06.520
на этом прощаюсь с вами
выпуск получился длинный - придется порезать

1:00:06.520,1:00:08.100
всего хорошего


0:00:01.280,0:00:14.990
всем привет прошлый раз остановились на

0:00:08.790,0:00:17.990
том что придется шифрование было

0:00:14.990,0:00:17.990
фейковая

0:00:28.530,0:00:33.300
так с тех пор утекло некоторое

0:00:30.330,0:00:37.850
количество воды я пытался здесь выпуск

0:00:33.300,0:00:40.560
но так сложилось что выпуск не записался

0:00:37.850,0:00:44.640
я так старался так много говорил но

0:00:40.560,0:00:46.590
просто так случилось начну просто

0:00:44.640,0:00:52.920
проведем review

0:00:46.590,0:00:55.920
того что написано и доработаем

0:00:52.920,0:01:11.990
немножечко этот код чтобы тесто

0:00:55.920,0:01:11.990
проходили по порядку начнем итак

0:01:19.890,0:01:24.110
после того как кот оформился в боевом

0:01:22.380,0:01:29.850
виде

0:01:24.110,0:01:31.409
в рио реальном виде работающим возникли

0:01:29.850,0:01:33.570
некоторые вопросы с текстовыми данными

0:01:31.409,0:01:36.110
но давайте обо всем по порядку начнем

0:01:33.570,0:01:36.110
skoda

0:01:39.110,0:01:43.310
когда я разрабатываю эту библиотеку

0:01:44.900,0:01:50.729
то совершил как бы классическую ошибку

0:01:47.520,0:01:52.920
начала зарабатывать библиотеку снизу мне

0:01:50.729,0:01:59.550
казалось что в плане шифрование мне все

0:01:52.920,0:02:10.229
понятно я начну снизу но получилось так

0:01:59.550,0:02:11.910
что я не смог нормально сделать сделать

0:02:10.229,0:02:16.980
так чтобы то библиотек можно было

0:02:11.910,0:02:19.940
использовать только сейчас у меня

0:02:16.980,0:02:25.860
сформировалось концептов этих щенков и

0:02:19.940,0:02:33.150
это стало понятно и тогда проект

0:02:25.860,0:02:35.489
взыскать подвис при этом низкоуровневая

0:02:33.150,0:02:37.850
часть на уровне блоков у меня уже

0:02:35.489,0:02:43.820
работает и даже уже проверил и

0:02:37.850,0:02:47.630
выкидывать сейчас весь этот код не стоит

0:02:43.820,0:02:54.410
мы сперва сделаем реализацию которой

0:02:47.630,0:02:58.350
работают на основе этого кода а потом

0:02:54.410,0:03:00.290
сделаем рефакторинг чтобы этот код

0:02:58.350,0:03:04.950
который написан ранее

0:03:00.290,0:03:05.790
стал лучше тогда я тоже сильно увлекся

0:03:04.950,0:03:12.720
линейностью

0:03:05.790,0:03:14.250
и то что написано по поводу шифрования

0:03:12.720,0:03:17.130
работы достаточно медленно и не

0:03:14.250,0:03:27.530
оптимально сейчас я уже вижу способа как

0:03:17.130,0:03:32.340
это можно изменить и так основной метод

0:03:27.530,0:03:34.170
алгоритм строим следующим образом мы не

0:03:32.340,0:03:36.030
знаю сколько данных поступать к вам на

0:03:34.170,0:03:46.220
вход это может быть любое количество

0:03:36.030,0:03:46.220
данных но алгоритм работает с блоками и

0:03:47.090,0:03:53.959
мы делаем следующим образом набираем

0:03:52.500,0:03:57.900
блок данных

0:03:53.959,0:03:58.200
если блок данных набрался мы шифру им

0:03:57.900,0:04:04.620
его

0:03:58.200,0:04:06.510
и записываем в поток во все это

0:04:04.620,0:04:10.620
возвращаемся набираем следующий блок

0:04:06.510,0:04:15.709
данных здесь все можно сделать optima не

0:04:10.620,0:04:19.590
это пока первый пробный вариант когда

0:04:15.709,0:04:23.640
эту порцию данных обработали до конца не

0:04:19.590,0:04:25.490
важно насколько заполнился блок вы

0:04:23.640,0:04:30.990
смотрим новый контекст

0:04:25.490,0:04:37.130
который включает в себя остатки этих

0:04:30.990,0:04:37.130
данных которые еще не зашифрованы и

0:04:38.120,0:04:45.020
состоянии шифратора

0:04:41.419,0:04:45.020
состояния шифратора

0:04:47.810,0:04:54.240
то есть у нас в процессе шифрования

0:04:51.030,0:04:59.180
всегда висят какие данные которые еще не

0:04:54.240,0:05:01.670
обработаны когда вызывается финал айс

0:04:59.180,0:05:05.180
наша задача этот хвост

0:05:01.670,0:05:05.180
обработать до конца

0:05:12.409,0:05:19.819
ну ты набрал тут у меня все сломается с

0:05:15.199,0:05:26.059
колесом я не учел что данных может быть

0:05:19.819,0:05:30.439
меньше чем восемь байт и записывать надо

0:05:26.059,0:05:33.759
меньше очень восемь байт надо записать

0:05:30.439,0:05:33.759
себе в пруду этот вопрос

0:05:41.310,0:05:47.460
так для того чтобы это все было

0:05:43.440,0:05:52.310
возможным появились более широкие

0:05:47.460,0:05:52.310
конструкторы и более широкий контекст

0:05:55.640,0:06:01.920
важный момент что все это константные

0:05:59.450,0:06:04.610
никакие данные не меняются в процессе

0:06:01.920,0:06:04.610
работы

0:06:18.190,0:06:20.700
так

0:06:20.960,0:06:25.270
в тест тоже претерпел некоторые

0:06:23.389,0:06:29.139
изменения

0:06:25.270,0:06:38.710
первое изменение заключается в том что

0:06:29.139,0:06:38.710
исходные данные проще перейти в код

0:06:46.110,0:06:54.510
исходные данные для этого теста

0:06:47.940,0:06:58.950
представлены в виде 64-битных часов это

0:06:54.510,0:07:04.950
старший бит это младший бит если мы

0:06:58.950,0:07:07.580
хотим передавать их как объекта то этот

0:07:04.950,0:07:15.740
вот только тобой ты должен стать первым

0:07:07.580,0:07:15.740
дат вас 8 этот очередным и так далее

0:07:19.490,0:07:24.470
когда и дел первую неудачную сессию

0:07:22.210,0:07:29.530
потребовал довольно много времени чтобы

0:07:24.470,0:07:29.530
эти моменты согласовать утрясти

0:07:36.289,0:07:44.749
одна из мыслей которым я тоже посетили

0:07:38.509,0:07:47.649
касается этого ключа у меня нет

0:07:44.749,0:07:50.509
абстрактного интерфейса плеча

0:07:47.649,0:07:53.559
тогда мне казался не нужен а сейчас мне

0:07:50.509,0:07:53.559
кажется необходимым

0:07:54.999,0:08:03.559
потому что вот таким образом мы не

0:07:57.529,0:08:07.399
сможем сделать ключ инкапсулирует себя

0:08:03.559,0:08:09.289
алгоритм обработки данных и таким

0:08:07.399,0:08:10.959
образом мы сможем сделать что-то

0:08:09.289,0:08:14.599
алгоритм

0:08:10.959,0:08:17.709
в этот джейлин под возможности системы

0:08:14.599,0:08:20.689
а это довольно важно для

0:08:17.709,0:08:22.839
производительности потому что он может

0:08:20.689,0:08:28.249
быть реализован мной сосне и

0:08:22.839,0:08:32.810
навык все либо на гене реконструкция

0:08:28.249,0:08:36.979
дженерик и подход вот в этом плане

0:08:32.810,0:08:42.440
создания ключа должен быть другой но

0:08:36.979,0:08:46.990
сейчас мы используем то что есть сперва

0:08:42.440,0:08:52.540
нужно сделать чтобы работает и впредь

0:08:46.990,0:08:52.540
преть никогда не начинать снизу вверх

0:08:52.810,0:09:03.540
всегда нужно идти ты от потребностей

0:08:55.579,0:09:05.790
приложений и углубляться в детали так

0:09:03.540,0:09:12.750
и тебя не хранится в обратном порядке

0:09:05.790,0:09:16.620
поэтому тут этот метод этот метод стал

0:09:12.750,0:09:20.810
сложнее здесь приходится учитывать тот

0:09:16.620,0:09:20.810
факт что данные необходимо перевернуть

0:09:26.700,0:09:30.020
и это еще не все

0:09:36.850,0:09:40.319
если запустить тест

0:09:43.400,0:09:49.930
тест показывает байтовые потоки

0:09:52.200,0:09:59.300
вот то чтобы долго горит на такая те

0:09:57.240,0:10:02.900
стены

0:09:59.300,0:10:08.720
db 37

0:10:02.900,0:10:12.870
сигнальные перевернуты те данные которые

0:10:08.720,0:10:16.170
я с которыми я пытаюсь сравнивать они

0:10:12.870,0:10:18.090
тоже все перевернуто вверх-ногами все

0:10:16.170,0:10:20.580
хранятся величественность четырех битных

0:10:18.090,0:10:25.620
чисел у которых младший байт здесь

0:10:20.580,0:10:31.730
старше палец здесь и получается обычный

0:10:25.620,0:10:31.730
текст матч нам не подходит

0:10:37.840,0:10:42.060
нам нужно сделать его по-другому

0:10:55.110,0:10:58.700
в чем мы сейчас займемся

0:11:01.230,0:11:06.850
становится непонятно зачем я здесь общих

0:11:03.850,0:11:13.809
x-match если его не будучи с

0:11:06.850,0:11:18.999
использовать я подумал о том чтобы

0:11:13.809,0:11:21.720
перенести его вообще тут мне почему-то

0:11:18.999,0:11:21.720
часто нужны

0:12:06.750,0:12:10.640
храним мы также исходную строку

0:12:58.390,0:13:06.180
так как же сделать сравнению с него нам

0:13:01.360,0:13:06.180
нужно его или при работать

0:13:33.779,0:13:38.040
техно нужно наш образец который нас

0:13:36.329,0:13:43.110
хранится внутри которой мы здесь

0:13:38.040,0:13:45.350
избавили от пробелов развернуть о 16

0:13:43.110,0:13:45.350
символов

0:13:57.550,0:14:00.600
это лучше тем

0:14:07.980,0:14:11.240
тексты мне не константа

0:14:23.260,0:14:28.170
на дачу перейдем к алгоритм до

0:14:51.490,0:14:58.529
на реверсе по два байта

0:14:54.930,0:14:58.529
что получается

0:15:18.310,0:15:21.180
кекс

0:15:44.070,0:15:51.510
делаем что можем успеть пробил хочу ли

0:15:48.910,0:15:51.510
оставить пробелы

0:16:23.939,0:16:26.839
да можно

0:18:20.250,0:18:24.289
общий довольно много букв

0:18:25.830,0:18:34.110
windows работать вот наши летчики

0:18:29.730,0:18:36.620
списать будет меньше терминальных

0:18:34.110,0:18:36.620
условий

0:18:49.420,0:18:52.230
что приводит

0:19:15.720,0:19:28.530
из них ждет проще и менее ход об этом

0:19:20.890,0:19:28.530
сильно так что напье комплекса

0:19:40.090,0:19:42.630
так вот

0:19:43.700,0:19:53.590
улучшен алгоритм вам чтоб программу так

0:19:49.940,0:19:53.590
и песни правил

0:20:01.440,0:20:12.289
текст на часик и здесь пишем текст

0:20:09.720,0:20:12.289
учитывать

0:20:12.379,0:20:15.379
здесь

0:20:19.110,0:20:23.450
надо написать описание

0:20:55.120,0:21:02.230
да зачем мы все это делаем хотел

0:20:57.250,0:21:07.570
пояснить в таком виде

0:21:02.230,0:21:09.460
эти данные приведены в гости их можно

0:21:07.570,0:21:12.550
было бы конечно перевернуть расставить

0:21:09.460,0:21:14.800
по бантиком но тогда бы они перестали

0:21:12.550,0:21:17.130
быть похожими на данные приведены в

0:21:14.800,0:21:17.130
гости

0:21:32.330,0:21:34.840
пробуй

0:21:37.210,0:21:41.700
текст сломался . ты забыл

0:21:48.130,0:21:55.860
для меня здесь такому-то клиника может

0:21:50.830,0:21:55.860
быть если подумать можно сделать лучше

0:21:58.120,0:22:01.870
все тесты прошли

0:22:06.690,0:22:11.070
там если подумать возможные входные

0:22:08.310,0:22:13.760
данные стоит как-то более единообразно

0:22:11.070,0:22:13.760
подавать на вход

0:22:17.570,0:22:25.760
возможно я смогу использовать тот же

0:22:19.770,0:22:25.760
сообщества духу специальный до

0:22:32.039,0:22:35.989
специальный собственно хорошая идея

0:22:53.380,0:22:57.049
так и давайте немножечко остановимся на

0:22:55.450,0:23:00.489
том

0:22:57.049,0:23:00.489
что плохо

0:23:06.390,0:23:10.140
существующий реализации

0:23:17.670,0:23:32.650
существующая виза ция текущей алгоритм у

0:23:22.150,0:23:36.240
нас построен на блоках возможно нам это

0:23:32.650,0:23:41.220
абстракция вообще не нужно

0:23:36.240,0:23:41.220
учитывая что ли так собрал данный блог

0:23:50.470,0:23:58.390
хоть этот вопрос стоит о том как сделать

0:23:54.400,0:24:02.950
такой не тот который примет на фон

0:23:58.390,0:24:06.659
данные в разной форме делать

0:24:02.950,0:24:06.659
перегруженные методы это плохая идея

0:24:08.520,0:24:13.809
но может быть действительно какой-нибудь

0:24:11.370,0:24:19.780
вспомогательный класс

0:24:13.809,0:24:23.850
но бы решить эту проблему и также

0:24:19.780,0:24:23.850
вспомогательный cost может за 1кк сорить

0:24:32.429,0:24:38.450
что буду рад как не был таким большим

0:24:35.749,0:24:42.049
преобразование осуществляется через сеть

0:24:38.450,0:24:47.220
что касатики

0:24:42.049,0:24:50.570
я сделал ошибку предположив что данные в

0:24:47.220,0:24:50.570
любом виде это клинче

0:25:02.179,0:25:12.610
мой ключ может создаваться из разных

0:25:04.970,0:25:12.610
совершенно методов это не совсем верны

0:25:13.419,0:25:20.090
учитывая что в конструкторе мы никакой

0:25:15.769,0:25:22.720
код не хотим писать эти данные с ирой

0:25:20.090,0:25:26.889
форме не всегда хорошо приспособлены для

0:25:22.720,0:25:26.889
произведений операции над ними и

0:25:29.379,0:25:36.289
подходите с должен быть другим

0:25:33.039,0:25:37.100
мы должны ввести понятие ключевых

0:25:36.289,0:25:39.769
контейнеры

0:25:37.100,0:25:45.850
пришла контейнер может существовать в

0:25:39.769,0:25:45.850
разной форме текстовый файл еще что-то

0:25:46.059,0:25:55.970
ключевой контейнер и так фабрика ключей

0:25:50.649,0:25:58.490
ты запрашивает ключ и тут еще такая

0:25:55.970,0:26:02.450
тонкость есть так тоже скал ключи должны

0:25:58.490,0:26:08.269
быть разными если я хочу делать

0:26:02.450,0:26:11.269
расчетные на апексе мне в другой форме

0:26:08.269,0:26:13.720
нужно представлять zbox совершенно в

0:26:11.269,0:26:13.720
другой форме

0:26:16.179,0:26:21.820
сидит на цикл с боксом для представлены

0:26:19.809,0:26:22.919
в виде разборного подвернутые 3 столбик

0:26:21.820,0:26:30.100
из чисел

0:26:22.919,0:26:36.029
которых там 4000 или нет 1004 раз

0:26:30.100,0:26:40.570
подвести существ здесь я делаю все то

0:26:36.029,0:26:44.409
есть бокс превращается в таблицу

0:26:40.570,0:26:56.230
перестановок который занимает дай бог

0:26:44.409,0:27:04.149
памяти 64 до 8 байт убит короче

0:26:56.230,0:27:07.509
маленькой трона как свёрнутую сбоку вот

0:27:04.149,0:27:17.429
и когда мы исключим контейнера будем

0:27:07.509,0:27:22.559
строить ключ нужно передать некий helper

0:27:17.429,0:27:26.129
который будет знать как ключевые данные

0:27:22.559,0:27:30.419
ключи spokes нужно разложить спаллетти

0:27:26.129,0:27:30.419
спайка как создать ключ

0:27:32.179,0:27:37.940
фабричный мет из принципе довольны

0:27:34.159,0:27:41.629
юзабельный штука я их может быть

0:27:37.940,0:27:47.299
поначалу недооценивал как надо будет все

0:27:41.629,0:27:49.100
переработать и когда сюита переработку я

0:27:47.299,0:27:50.840
смогу производительности сравниться по

0:27:49.100,0:27:55.669
нас с элем но и другими реализациями

0:27:50.840,0:27:58.580
надеюсь не будет сильно хуже если это не

0:27:55.669,0:28:05.629
будет на порядок хуже это будет уже

0:27:58.580,0:28:10.159
большая победа на этом я наверно закончу

0:28:05.629,0:28:12.879
сегодняшний выпуск всем пока до новых

0:28:10.159,0:28:12.879
встреч

